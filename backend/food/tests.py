"""this file generated by ai"""

from datetime import date, timedelta
import json

from django.core.exceptions import ValidationError
from rest_framework.test import APIClient
from rest_framework import status
from django.test import TestCase
from django.urls import reverse


from food.models import FoodDate, PredefinedFood, SideFishes, Food
from accounts.tests import FullFlowAccountTest


class FoodTests(TestCase):
    def setUp(self):
        self.client = APIClient()

        # Create test user and get auth token
        account_test = FullFlowAccountTest()
        account_test.client = self.client
        account_test.create_user()
        account_test.login()
        self.auth_header = account_test.auth_header

        # Create a full week of food dates starting from Saturday
        today = date.today()
        # Find most recent Saturday
        self.start_of_week = today - timedelta(days=(today.weekday() + 2) % 7)
        self.food_dates = [
            FoodDate.objects.get_or_create(date=self.start_of_week + timedelta(days=i))[
                0
            ]
            for i in range(7)  # Saturday (0) to Friday (6)
        ]

        # Create test food for tomorrow
        tomorrow = today + timedelta(days=1)
        self.food_date = FoodDate.objects.get_or_create(date=tomorrow)[0]
        self.predefined_food = PredefinedFood.objects.create(
            name="Test Food", food_type="pl", description="Test description"
        )
        self.side_fish = SideFishes.objects.create(name="Extra Sauce")
        self.food = Food.objects.create(
            food_date=self.food_date,
            predefined_food=self.predefined_food,
            food_type="pl",
        )
        self.food.side_fishes.add(self.side_fish)

    def test_food_validation(self):
        food_date = FoodDate.objects.create(date=date.today() + timedelta(days=8))
        food = Food.objects.create(food_date=food_date, food_type="pl")
        with self.assertRaises(ValidationError):
            food.full_clean()  # This should fail validation

    def test_can_reserve_field(self):
        # Create dates outside the current week range to avoid duplicates
        future_date = self.start_of_week + timedelta(days=10)  # Next week
        past_date = self.start_of_week - timedelta(days=10)  # Previous week

        future_food_date = FoodDate.objects.create(date=future_date)
        past_food_date = FoodDate.objects.create(date=past_date)

        # Get the week containing our test dates
        url = reverse("foods:week-foods") + f"?start-date={future_date.isoformat()}"
        response = self.client.get(url, headers=self.auth_header)
        data = json.loads(response.content.decode())

        # Check the future date
        found_future = any(fd["date"] == future_date.isoformat() for fd in data)
        self.assertTrue(found_future, "Future date not found in response")
        if found_future:
            future_data = next(
                fd for fd in data if fd["date"] == future_date.isoformat()
            )
            self.assertTrue(future_data["can_reserve"])

        # Check the past date
        url = reverse("foods:week-foods") + f"?start-date={past_date.isoformat()}"
        response = self.client.get(url, headers=self.auth_header)
        data = json.loads(response.content.decode())

        found_past = any(fd["date"] == past_date.isoformat() for fd in data)
        self.assertTrue(found_past, "Past date not found in response")
        if found_past:
            past_data = next(fd for fd in data if fd["date"] == past_date.isoformat())
            self.assertFalse(past_data["can_reserve"])

    def test_food_date_serializer(self):
        url = reverse("foods:week-foods")
        response = self.client.get(url, headers=self.auth_header)
        data = json.loads(response.content.decode())

        # Check if our test food date is in the response
        found = False
        for food_date in data:
            if food_date["date"] == self.food_date.date.isoformat():
                found = True
                self.assertEqual(len(food_date["foods"]), 1)
                self.assertEqual(
                    food_date["foods"][0]["predefined_food"]["name"], "Test Food"
                )
                self.assertEqual(len(food_date["foods"][0]["side_fishes"]), 1)
                self.assertEqual(
                    food_date["foods"][0]["side_fishes"][0]["name"], "Extra Sauce"
                )
                break
        self.assertTrue(found, "Test food date not found in response")

    def test_get_foods_without_date(self):
        url = reverse("foods:week-foods")
        response = self.client.get(url, headers=self.auth_header)
        data = json.loads(response.content.decode())

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # Should return the current week (7 days)
        self.assertEqual(
            len(data),
            7,
            f"Expected 7 days, got {len(data)}. "
            f"Current week starts on {self.start_of_week}",
        )
        # Verify all dates are consecutive
        dates = [fd["date"] for fd in data]
        for i in range(1, 7):
            prev_date = date.fromisoformat(dates[i - 1])
            curr_date = date.fromisoformat(dates[i])
            self.assertEqual((curr_date - prev_date).days, 1)

    def test_food_creation_through_predefined(self):
        # Use a date far in the future to avoid conflicts
        future_date = date.today() + timedelta(days=30)
        food_date = FoodDate.objects.get_or_create(date=future_date)[0]
        food = Food.objects.create(
            food_date=food_date, predefined_food=self.predefined_food, food_type="pl"
        )
        self.assertEqual(str(food), "Test Food")

    def test_food_creation_with_custom_name(self):
        # Use a different future date to avoid conflicts
        future_date = date.today() + timedelta(days=31)
        food_date = FoodDate.objects.get_or_create(date=future_date)[0]
        food = Food.objects.create(
            food_date=food_date, custom_name="Custom Food", food_type="br"
        )
        # Should automatically create a predefined food
        self.assertTrue(PredefinedFood.objects.filter(name="Custom Food").exists())
        self.assertEqual(str(food), "Custom Food")

    def test_side_fishes_relationship(self):
        self.assertEqual(self.side_fish.foods.count(), 0)
        self.side_fish.foods.add(self.predefined_food)
        self.assertEqual(self.side_fish.foods.count(), 1)

    def test_unauthenticated_access(self):
        url = reverse("foods:week-foods")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    # def test_admin_permissions(self):
    #     # Test that non-admin users can only read (not create/update/delete)
    #     # This would require additional setup with a non-admin user
    #     pass
